<template>
  <div class="calendar-dashboard">
    <!-- Calendar Header -->
    <div
      class="flex flex-col sm:flex-row justify-between items-center mb-6 p-4 bg-white rounded-lg shadow-sm"
    >
      <div class="flex items-center space-x-3 mb-4 sm:mb-0">
        <button class="btn-icon" @click="goToPreviousWeek">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            class="h-5 w-5"
            viewBox="0 0 20 20"
            fill="currentColor"
          >
            <path
              fill-rule="evenodd"
              d="M12.707 5.293a1 1 0 010 1.414L9.414 10l3.293 3.293a1 1 0 01-1.414 1.414l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 0z"
              clip-rule="evenodd"
            />
          </svg>
        </button>
        <button class="btn-icon sm:hidden" @click="goToPreviousDay">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            class="h-5 w-5"
            viewBox="0 0 20 20"
            fill="currentColor"
          >
            <path
              fill-rule="evenodd"
              d="M12.707 5.293a1 1 0 010 1.414L9.414 10l3.293 3.293a1 1 0 01-1.414 1.414l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 0z"
              clip-rule="evenodd"
            />
          </svg>
        </button>
        <span class="text-xl font-semibold text-gray-800">{{
          currentWeekRange
        }}</span>
        <button class="btn-icon sm:hidden" @click="goToNextDay">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            class="h-5 w-5"
            viewBox="0 0 20 20"
            fill="currentColor"
          >
            <path
              fill-rule="evenodd"
              d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z"
              clip-rule="evenodd"
            />
          </svg>
        </button>
        <button class="btn-icon" @click="goToNextWeek">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            class="h-5 w-5"
            viewBox="0 0 20 20"
            fill="currentColor"
          >
            <path
              fill-rule="evenodd"
              d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z"
              clip-rule="evenodd"
            />
          </svg>
        </button>
        <button class="btn-outline ml-4" @click="goToToday">Hoy</button>
      </div>

      <div
        class="flex flex-col sm:flex-row items-center space-y-3 sm:space-y-0 sm:space-x-4 w-full sm:w-auto"
      >
        <!-- Barber/Team Selector -->
        <CustomSelect
          :modelValue="selectedBarberFilter"
          @update:modelValue="selectedBarberFilter = $event"
          :options="barberSelectOptions"
          placeholder="Seleccionar Barbero"
          class="w-full sm:w-48"
        />

        <!-- Add Button -->
        <button
          class="btn-primary w-full sm:w-48"
          @click="openAddAppointmentModal"
        >
          <svg
            xmlns="http://www.w3.org/2000/svg"
            class="h-5 w-5 mr-2"
            viewBox="0 0 20 20"
            fill="currentColor"
          >
            <path
              fill-rule="evenodd"
              d="M10 5a1 1 0 011 1v3h3a1 1 0 110 2h-3v3a1 1 0 11-2 0v-3H6a1 1 0 110-2h3V6a1 1 0 011-1z"
              clip-rule="evenodd"
            />
          </svg>
          AÃ±adir Cita
        </button>
      </div>
    </div>

    <!-- Main Calendar Grid -->
    <div class="relative">
      <div
        class="calendar-main-grid grid grid-cols-[48px_1fr] md:grid-cols-[60px_repeat(4,_minmax(0,_1fr))] lg:grid-cols-[60px_repeat(7,_minmax(0,_1fr))] gap-px bg-gray-200 rounded-lg overflow-hidden shadow-lg"
      >
        <!-- Time Axis Header (empty corner) -->
        <div
          class="bg-white p-2 border-b border-r border-gray-200 h-[76px]"
        ></div>

        <!-- Day Headers -->
        <div
          v-for="day in displayedDays"
          :key="day.fullDate"
          class="day-header bg-white p-2 text-center font-semibold text-gray-700 border-b border-r border-gray-200 h-[76px]"
          :class="{
            'bg-blue-50 text-blue-700':
              day.fullDate === dayjs().format('YYYY-MM-DD'),
          }"
        >
          <span class="block text-xs sm:text-sm uppercase">{{ day.name }}</span>
          <span class="block text-xl font-bold">{{
            day.date.split(' ')[0]
          }}</span>
          <span class="hidden sm:block text-xs text-gray-500">{{
            day.date.split(' ')[1]
          }}</span>
        </div>

        <!-- Time Axis and Day Columns -->
        <template v-for="(hour, index) in hours" :key="hour">
          <!-- Time Label -->
          <div
            class="time-label bg-white p-2 text-right text-xs text-gray-500 border-r border-gray-200 flex items-start justify-end pr-2"
            :style="{ height: '60px' }"
          >
            <span v-if="index % 2 !== 1">{{ hour.slice(0, 5) }}</span>
          </div>
          <!-- Day Cells -->
          <div
            v-for="day in displayedDays"
            :key="day.fullDate + '-' + hour"
            class="day-cell relative bg-white border-b border-r border-gray-200 h-[60px] cursor-pointer hover:bg-blue-50"
            @click="
              openAddAppointmentModalWithTime(
                selectedBarberFilter === 'all' ||
                  selectedBarberFilter === 'scheduled'
                  ? null
                  : selectedBarberFilter,
                day.fullDate,
                hour,
              )
            "
          >
            <!-- Cells are now empty, serving as the background grid -->
          </div>
        </template>
      </div>

      <!-- Appointments Overlay -->
      <div
        class="appointments-overlay absolute inset-0 grid grid-cols-[48px_1fr] md:grid-cols-[60px_repeat(4,_minmax(0,_1fr))] lg:grid-cols-[60px_repeat(7,_minmax(0,_1fr))] gap-px pointer-events-none"
      >
        <div
          v-for="(day, index) in displayedDays"
          :key="day.fullDate"
          class="day-column relative"
          :style="{ 'grid-column': index + 2 }"
        >
          <div
            v-for="reservation in getFilteredReservationsForDay(day.fullDate)"
            :key="reservation.id"
            class="appointment absolute flex flex-col justify-between rounded-lg p-2 text-gray-800 bg-white border border-gray-200 border-l-8 shadow-lg cursor-pointer pointer-events-auto overflow-hidden"
            :style="getAppointmentStyle(reservation)"
            @click.stop="viewAppointmentDetails(reservation)"
          >
            <!-- Top part with info -->
            <div class="flex-grow">
              <div class="font-bold text-xs sm:text-sm text-gray-900 truncate">
                {{ reservation.client_name }}
              </div>
              <div class="text-xxs sm:text-xs text-gray-600 truncate">
                {{ getBarberName(reservation.barber_id) }}
              </div>
              <div class="text-xs text-gray-500 mt-1 flex items-center">
                <svg
                  xmlns="http://www.w3.org/2000/svg"
                  class="h-3 w-3 inline-block mr-1"
                  viewBox="0 0 20 20"
                  fill="currentColor"
                >
                  <path
                    fill-rule="evenodd"
                    d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-12a1 1 0 10-2 0v4a1 1 0 00.293.707l2.828 2.829a1 1 0 101.414-1.415L11 9.586V6z"
                    clip-rule="evenodd"
                  />
                </svg>
                {{ formatTime(reservation.start_time) }} -
                {{ formatTime(reservation.end_time) }}
              </div>
            </div>

            <!-- Bottom part with status -->
            <div
              class="status-tag text-xs font-semibold text-center py-1 px-2 rounded-md mt-2 self-start"
              :class="{
                'bg-yellow-100 text-yellow-800': reservation.status !== 'paid',
                'bg-green-100 text-green-800': reservation.status === 'paid',
              }"
            >
              {{ reservation.status === 'paid' ? 'Pagado' : 'Reservado' }}
            </div>
          </div>
        </div>
      </div>

      <!-- Current Time Indicator -->
      <div
        v-if="showCurrentTimeIndicator"
        class="current-time-indicator absolute left-0 right-0 border-t-2 border-red-500 z-30 pointer-events-none"
        :style="{ top: currentTimeIndicatorPosition }"
      >
        <div
          class="absolute -left-1.5 -top-1.5 w-3 h-3 bg-red-500 rounded-full"
        ></div>
      </div>
    </div>

    <ReservationFormModal
      :show="isAddAppointmentModalOpen"
      :initialBarberId="selectedBarberId"
      :initialDate="selectedDate"
      :initialHour="selectedHour"
      @close="isAddAppointmentModalOpen = false"
      @reservationCreated="fetchReservationsForCurrentWeek"
    />

    <SaleRegistrationModal
      :show="isSaleRegistrationModalOpen"
      :reservation="reservationToSell"
      @close="isSaleRegistrationModalOpen = false"
      @saleProcessed="fetchReservationsForCurrentWeek"
      @updatedReservation="handleUpdatedReservation"
    />

    <SaleDetailsModal
      :show="isSaleDetailsModalOpen"
      :reservationId="selectedReservationId"
      @close="isSaleDetailsModalOpen = false"
    />
  </div>
</template>

<script setup>
import { ref, computed, onMounted, watch } from 'vue';
import api from '../services/api'; // Import the centralized Axios instance
import SaleRegistrationModal from '../components/SaleRegistrationModal.vue';
import ReservationFormModal from '../components/ReservationFormModal.vue';
import SaleDetailsModal from '../components/SaleDetailsModal.vue';
import dayjs from 'dayjs';
import 'dayjs/locale/es';
import utc from 'dayjs/plugin/utc';
import localizedFormat from 'dayjs/plugin/localizedFormat';
import isSameOrAfter from 'dayjs/plugin/isSameOrAfter';

dayjs.locale('es');
dayjs.extend(utc);
dayjs.extend(localizedFormat);
dayjs.extend(isSameOrAfter);

import CustomSelect from '../components/CustomSelect.vue';

// Define a set of colors for barbers
const colors = [
  '#EF4444', // Red-500
  '#3B82F6', // Blue-500
  '#10B981', // Green-500
  '#F59E0B', // Amber-500
  '#6366F1', // Indigo-500
  '#EC4899', // Pink-500
  '#8B5CF6', // Purple-500
];

// Reactive map to store barber colors
const barberColors = ref({});

// Data refs
const reservations = ref([]);
const barbers = ref([]);
const services = ref([]);

// Function to assign colors to barbers
const assignBarberColors = () => {
  barbers.value.forEach((barber, index) => {
    barberColors.value[barber.id] = {
      bgColor: colors[index % colors.length],
      borderColor: colors[index % colors.length].replace('500', '700'), // Darker shade for border
    };
  });
};

const barberSelectOptions = computed(() => {
  const options = [
    { label: 'Todo el equipo', value: 'all' },
    { label: 'Equipo programado', value: 'scheduled' },
  ];
  barbers.value.forEach((barber) => {
    options.push({
      label: barber.name,
      value: barber.id,
      style: {
        backgroundColor: barberColors.value[barber.id]?.bgColor,
        color: 'white',
      },
    });
  });
  return options;
});

const currentWeekStart = ref(dayjs().startOf('week'));
const selectedBarberFilter = ref('all');
const isAddAppointmentModalOpen = ref(false);
const isSaleRegistrationModalOpen = ref(false);
const reservationToSell = ref(null);
const isSaleDetailsModalOpen = ref(false);
const selectedReservationId = ref(null);

const selectedBarberId = ref(null);
const selectedDate = ref(null);
const selectedHour = ref(null);

const headerHeight = 76; // Height of the day headers
const timeAxisWidth = computed(() => {
  const screenWidth = window.innerWidth;
  return screenWidth < 768 ? 48 : 60; // 48px for mobile, 60px for tablet/desktop
});

const activeDayIndex = ref(0); // For mobile single-day view

const weekDays = computed(() => {
  const days = [];
  for (let i = 0; i < 7; i++) {
    const date = currentWeekStart.value.add(i, 'day');
    days.push({
      name: date.format('ddd'),
      date: date.format('DD MMM'),
      fullDate: date.format('YYYY-MM-DD'),
    });
  }
  return days;
});

const displayedDays = computed(() => {
  const screenWidth = window.innerWidth; // Get current screen width
  const days = weekDays.value; // All 7 days of the week

  if (screenWidth < 768) {
    // Mobile (sm breakpoint is 640px, md is 768px)
    return [days[activeDayIndex.value]]; // Show only the active day
  } else if (screenWidth < 1024) {
    // Tablet (lg breakpoint is 1024px)
    // Show 4 days for tablet, starting from the activeDayIndex
    const start = activeDayIndex.value;
    const end = Math.min(start + 4, days.length);
    return days.slice(start, end);
  } else {
    // Desktop
    return days; // Show all 7 days
  }
});

const currentWeekRange = computed(() => {
  const start = currentWeekStart.value.format('DD MMM');
  const end = currentWeekStart.value.add(6, 'day').format('DD MMM, YYYY');
  return `${start} - ${end}`;
});

const hours = computed(() => {
  const h = [];
  for (let i = 8; i <= 22; i++) {
    h.push(`${i.toString().padStart(2, '0')}:00`);
    if (i < 22) {
      h.push(`${i.toString().padStart(2, '0')}:30`);
    }
  }
  return h;
});

const currentTimeIndicatorPosition = computed(() => {
  const now = dayjs();
  const startHour = 8; // Calendar starts at 8:00 AM
  const totalMinutesFromStart = (now.hour() - startHour) * 60 + now.minute();
  const pixelsPerHalfHour = 100; // Further increased for more vertical space
  const top = (totalMinutesFromStart / 30) * pixelsPerHalfHour;
  const headerHeight = 76; // Height of the day headers

  // Only return a value if the current time is within the displayed hours
  if (now.hour() >= startHour && now.hour() <= 22) {
    return `${top + headerHeight}px`;
  }
  return '-9999px'; // Position off-screen if not in range
});

const showCurrentTimeIndicator = computed(() => {
  const now = dayjs();
  return now.isSame(currentWeekStart.value, 'week');
});

const goToToday = () => {
  currentWeekStart.value = dayjs().startOf('week');
};

const goToPreviousWeek = () => {
  currentWeekStart.value = currentWeekStart.value.subtract(1, 'week');
};

const goToNextWeek = () => {
  currentWeekStart.value = currentWeekStart.value.add(1, 'week');
};

const goToPreviousDay = () => {
  if (activeDayIndex.value > 0) {
    activeDayIndex.value--;
  } else {
    // If at the first day of the week, go to the last day of the previous week
    currentWeekStart.value = currentWeekStart.value.subtract(1, 'week');
    activeDayIndex.value = 6; // Last day of the new week
  }
};

const goToNextDay = () => {
  if (activeDayIndex.value < 6) {
    activeDayIndex.value++;
  } else {
    // If at the last day of the week, go to the first day of the next week
    currentWeekStart.value = currentWeekStart.value.add(1, 'week');
    activeDayIndex.value = 0; // First day of the new week
  }
};

const calculateOverlappingAppointmentsLayout = (reservations) => {
  if (!reservations || reservations.length === 0) {
    return [];
  }

  // Sort reservations by start time
  reservations.sort((a, b) =>
    dayjs(a.start_time).local().diff(dayjs(b.start_time).local()),
  );

  const processedReservations = [];
  const columns = []; // Stores the end time of the last reservation in each column

  reservations.forEach((res) => {
    const start = dayjs(res.start_time).local();
    const end = dayjs(res.end_time).local();

    let assignedColumn = -1;

    // Try to fit the reservation into an existing column
    for (let i = 0; i < columns.length; i++) {
      if (start.isSameOrAfter(columns[i])) {
        assignedColumn = i;
        break;
      }
    }

    // If no column found, create a new one
    if (assignedColumn === -1) {
      assignedColumn = columns.length;
      columns.push(null);
    }

    // Update the end time for the assigned column
    columns[assignedColumn] = end;

    // Store the column index with the reservation
    processedReservations.push({ ...res, column: assignedColumn });
  });

  // Now calculate max columns needed for each overlap group and assign final left/width
  processedReservations.forEach((res) => {
    const overlappingGroup = processedReservations.filter((otherRes) => {
      const resStart = dayjs(res.start_time).local();
      const resEnd = dayjs(res.end_time).local();
      const otherResStart = dayjs(otherRes.start_time).local();
      const otherResEnd = dayjs(otherRes.end_time).local();

      // Check for overlap
      return resStart.isBefore(otherResEnd) && otherResStart.isBefore(resEnd);
    });

    const maxColumnsInGroup =
      Math.max(...overlappingGroup.map((o) => o.column)) + 1;
    const baseColumnWidth = 100 / maxColumnsInGroup;
    const effectiveWidth = baseColumnWidth * 0.98;
    const margin = baseColumnWidth * 0.01;
    const leftOffset = res.column * baseColumnWidth + margin;

    res.calculatedLeft = `${leftOffset}%`;
    res.calculatedWidth = `${effectiveWidth}%`;
  });

  return processedReservations;
};

const getFilteredReservationsForDay = (date) => {
  let reservationsForDay = reservations.value.filter(
    (res) => dayjs(res.start_time).local().format('YYYY-MM-DD') === date,
  );

  if (
    selectedBarberFilter.value !== 'all' &&
    selectedBarberFilter.value !== 'scheduled'
  ) {
    reservationsForDay = reservationsForDay.filter(
      (res) => res.barber_id === selectedBarberFilter.value,
    );
  } else if (selectedBarberFilter.value === 'scheduled') {
    // This logic needs to be implemented if 'scheduled' means something specific
    // For now, it will behave like 'all' if no specific logic is provided.
    // You might want to filter for barbers who have *any* reservation in the current week.
  }

  // Calculate layout for overlapping appointments
  return calculateOverlappingAppointmentsLayout(reservationsForDay);
};

const getAppointmentStyle = (reservation) => {
  const start = dayjs(reservation.start_time).local();
  const end = dayjs(reservation.end_time).local();
  const startHour = start.hour();
  const startMinute = start.minute();

  const pixelsPerHalfHour = 60;
  const topOffsetMinutes = (startHour - 8) * 60 + startMinute;
  let top = (topOffsetMinutes / 30) * pixelsPerHalfHour;

  // Adjust top for header height
  top += headerHeight;

  const durationMinutes = end.diff(start, 'minute');
  let height = (durationMinutes / 30) * pixelsPerHalfHour;

  if (height < 90) {
    height = 90;
  }

  const barberColor = barberColors.value[reservation.barber_id] || {
    bgColor: '#4299e1', // Default color
  };

  // Adjust left for time axis width
  let left = reservation.calculatedLeft;

  return {
    top: `${top}px`,
    height: `${height}px`,
    left: left, // Use the adjusted left
    width: reservation.calculatedWidth,
    borderLeftColor: barberColor.bgColor,
  };
};

const formatTime = (dateTimeString) => {
  return dayjs(dateTimeString).format('HH:mm');
};

const getBarberName = (barberId) => {
  const barber = barbers.value.find((b) => b.id === barberId);
  return barber ? barber.name : 'Desconocido';
};

const getServiceName = (serviceId) => {
  const service = services.value.find((s) => s.id === serviceId);
  return service ? service.name : 'Desconocido';
};

const openAddAppointmentModalWithTime = (barberId, date, hour) => {
  selectedBarberId.value = barberId;
  selectedDate.value = date;
  selectedHour.value = hour;
  isAddAppointmentModalOpen.value = true;
};

const openAddAppointmentModal = () => {
  selectedBarberId.value = null;
  selectedDate.value = null;
  selectedHour.value = null;
  isAddAppointmentModalOpen.value = true;
};

const viewAppointmentDetails = (reservation) => {
  if (reservation.status === 'paid') {
    selectedReservationId.value = reservation.id;
    isSaleDetailsModalOpen.value = true;
  } else {
    reservationToSell.value = reservation;
    isSaleRegistrationModalOpen.value = true;
  }
};

const fetchReservationsForCurrentWeek = async () => {
  const startDate = currentWeekStart.value.startOf('day').toISOString();
  const endDate = currentWeekStart.value
    .endOf('week')
    .endOf('day')
    .toISOString();
  try {
    const response = await api.get('/reservations/view/calendar', {
      // Use 'api' and relative path
      params: { startDate, endDate },
    });
    reservations.value = response.data.reservations;
    barbers.value = response.data.barbers;
    services.value = response.data.services;
    assignBarberColors(); // Re-assign colors after barbers are fetched
  } catch (error) {
    console.error('Error fetching calendar data:', error);
  }
};

const handleUpdatedReservation = (updatedReservation) => {
  const index = reservations.value.findIndex(
    (res) => res.id === updatedReservation.id,
  );
  if (index !== -1) {
    reservations.value[index] = updatedReservation;
  }
};

watch(currentWeekStart, fetchReservationsForCurrentWeek);
watch(selectedBarberFilter, fetchReservationsForCurrentWeek);

onMounted(() => {
  fetchReservationsForCurrentWeek();
});
</script>
